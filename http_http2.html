<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="helpfulvoltage" />
  <meta name="dcterms.date" content="2025-03-26" />
  <title>Http vs Http2, Implementations in Rust</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="styles.css">
  <script src="script.js"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Http vs Http2, Implementations in Rust</h1>
<p class="author">helpfulvoltage</p>
<p class="date">2025-03-26</p>
</header>
<p>today we are going to use <code>hyper</code> and <code>tokio</code>
to implement http2 in <code>rust</code>.</p>
<p>questions i am going to answer for you by the end of this
journal:</p>
<ul>
<li><ol type="1">
<li>what is http?</li>
</ol></li>
<li><ol start="2" type="1">
<li>what is http2?</li>
</ol></li>
<li><ol start="3" type="1">
<li>what is hyper?</li>
</ol></li>
<li><ol start="4" type="1">
<li>what is tokio?</li>
</ol></li>
<li><ol start="5" type="1">
<li>common alternatives to these for rust implementations?</li>
</ol></li>
<li><ol start="6" type="1">
<li>implementing fundamentals?</li>
</ol></li>
</ul>
<p>let’s begin!</p>
<hr />
<h2 id="notes">Notes</h2>
<p><code>HTTP</code> is the hyper text transfer protocol. ChatGPT
describes it as “the foundation of data communication on the world wide
web”. <em>makes sense</em> every site is served with HTTP(s) but we will
ignore that little s for now. the fundamental technology is
<code>http</code>!</p>
<ul>
<li>this software defines how clients (LIKE BROWSERS) and servers
communiate. [ PRIMARILY THRU REQUESTS AND RESPONSES ]</li>
<li>in this model, the client sends a http request and the server
responds with a http response.</li>
</ul>
<p><code>Request</code></p>
<ul>
<li>METHOD: GET, POST, PUT, etc…</li>
<li>HEADERS: metadata about the Request</li>
<li>BODY: optional data being sent</li>
</ul>
<p><code>Response</code></p>
<ul>
<li>STATUS: 200 success, 404 not found …</li>
<li>HEADERS: metadata about the response</li>
<li>BODY: the content requested (HTML, JSON, etc)</li>
</ul>
<p><code>HTTP</code> operates over <code>TCP/IP</code>!</p>
<hr />
<p><code>HTTP/2</code></p>
<ul>
<li><p>major revision of the HTTP protocol</p></li>
<li><p>designed to develop to improve speed, security, and efficiency
for modern web applications</p>
<ul>
<li><p>multiplexing</p></li>
<li><p>header compression</p></li>
<li><p>stream prioritization</p></li>
<li><p>server push</p></li>
</ul></li>
<li><p>in short, improvements across board which means better
performance and reliability.</p></li>
</ul>
<hr />
<p><code>Hyper</code></p>
<ul>
<li><p>hyper is a fast low level HTTP implementation for RUST.</p></li>
<li><p>IT IS async and designed for building HTTP clients and servers in
RUST.</p></li>
<li><p>supports http/1.x and http/2.x</p>
<ul>
<li><p>async</p></li>
<li><p>extensible</p></li>
<li><p>low level api</p></li>
</ul></li>
</ul>
<hr />
<p><code>Tokio</code></p>
<ul>
<li><p>async runtime for rust</p></li>
<li><p>designed to handle async I/O and is used as foundation for many
high performance rust apps</p>
<ul>
<li><p>async i/o</p></li>
<li><p>concurrency</p></li>
<li><p>built in components</p></li>
</ul></li>
</ul>
<hr />
<p><code>Alternatives section</code></p>
<ul>
<li>Actix Web: A highly concurrent web framework built on top of Actix
(a powerful actor-based framework). Actix Web provides a more
feature-rich and opinionated way to build web servers, with a focus on
performance.</li>
<li>Warp: A web framework built on top of Hyper, providing a more
ergonomic and functional API for creating HTTP servers. It’s a great
choice if you like combinator-style APIs.</li>
<li>Axum: Another framework built on Hyper and Tokio, which is designed
to make building async web apps easier. It provides a higher-level API
than Hyper and is ideal for users who prefer declarative APIs.</li>
<li>Smol: A small, fast async runtime that could be an alternative to
Tokio for simpler use cases. It’s less feature-rich but can be more
lightweight.</li>
</ul>
<hr />
<h2 id="notes-on-implementation">Notes on implementation</h2>
<blockquote>
<p>[!NOTE]</p>
<p><a href="https://docs.rs/hyper/latest/hyper/client/index.html">hyper
client docs</a></p>
</blockquote>
<p>Throughout the making of this first guide I want to improve my
efficiency at reading Rust documentation.</p>
<figure>
<img src="screenshot_2025-03-26_14-18-26.png"
alt="screenshot_2025-03-26_14-18-26.png" />
<figcaption
aria-hidden="true">screenshot_2025-03-26_14-18-26.png</figcaption>
</figure>
<p>This is the docs.rs page for the hyper client module.</p>
<p>In the context of hyper which is a package (correct?) what is a
module? how do I make sense of this documentation. what are
<code>Type Aliases</code>?</p>
<p>in the documentation I see that <code>hyper</code> has 8 modules:</p>
<ol type="1">
<li>body</li>
<li>client</li>
<li>ext</li>
<li>ffi</li>
<li>rt</li>
<li>server</li>
<li>service</li>
<li>upgrade</li>
</ol>
<p>I need a table that would tell me in short what they do.</p>
<p>also it seems that modules can have submodules. take for example
<code>client</code> module has the submodule <code>conn</code>. would I
be able to see a tree for each rust package? is it worth creating an
application that would show me a graphical tree (much like the tree
command in linux) but for the modules for a package. It might help me
better understand it as a whole.</p>
<h3 id="how-to-make-sense-of-documentation-guide">HOW TO MAKE SENSE OF
DOCUMENTATION GUIDE</h3>
<p>~ help from ChatGPT 4o</p>
<ul>
<li><strong>module</strong> = organizing code into smaller, logical
units.
<ul>
<li>A module in a Rust package (or crate) can group related functions,
types, and other definitions together.</li>
<li>Modules can be nested, and they help in managing complexity by
dividing the functionality of your application into manageable
parts.</li>
<li>The <code>hyper</code> crate is a package, and inside it, there are
several <strong>modules</strong> (like <code>client</code>,
<code>body</code>, <code>server</code>, etc.) that each encapsulate
specific functionality.</li>
<li>A module can also contain submodules, which are nested modules.</li>
</ul></li>
</ul>
<h4 id="start-from-the-top">1. <strong>Start from the Top</strong>:</h4>
<p>The documentation usually starts with a high-level overview of the
module or crate, outlining the most important concepts and how they tie
together.</p>
<blockquote>
<p>hyper is a fast and correct HTTP implementation written in and for
Rust. features: http1 and 2! async design tested and correct<br />
link to some guides <a href="https://hyper.rs/guides/1/">CLICK HERE FOR
THE GUIDES</a></p>
</blockquote>
<h4 id="look-at-the-structs-enums-and-functions">2. <strong>Look at the
Structs, Enums, and Functions</strong>:</h4>
<p>Once you understand the basic concepts, go deeper into the structs
(which represent data structures) and enums (which represent choices)
provided by the module. &gt; This is very interesting. &gt; STRUCTS =
DATA STRUCTURE. &gt; ENUM = CHOICE. &gt; wait i already knew that.</p>
<p>Each of these will be detailed in the documentation with fields,
methods, and examples.</p>
<p>struct list: - Error</p>
<p>enum list: - I can’t find them..</p>
<figure>
<img src="screenshot_2025-03-26_14-28-54.png"
alt="screenshot_2025-03-26_14-28-54.png" />
<figcaption
aria-hidden="true">screenshot_2025-03-26_14-28-54.png</figcaption>
</figure>
<blockquote>
<p>click <em>all items</em></p>
</blockquote>
<p>Structs Error body::Bytes body::Frame body::Incoming body::SizeHint
client::conn::TrySendError client::conn::http1::Builder
client::conn::http1::Connection client::conn::http1::Parts
client::conn::http1::SendRequest client::conn::http2::Builder
client::conn::http2::Connection client::conn::http2::SendRequest
ext::Protocol ext::ReasonPhrase ffi::hyper_body ffi::hyper_buf
ffi::hyper_clientconn ffi::hyper_clientconn_options ffi::hyper_context
ffi::hyper_error ffi::hyper_executor ffi::hyper_headers ffi::hyper_io
ffi::hyper_request ffi::hyper_response ffi::hyper_task ffi::hyper_waker
rt::ReadBuf rt::ReadBufCursor server::conn::http1::Builder
server::conn::http1::Connection server::conn::http1::Parts
server::conn::http1::UpgradeableConnection server::conn::http2::Builder
server::conn::http2::Connection upgrade::OnUpgrade upgrade::Parts
upgrade::Upgraded</p>
<p>Enums ffi::hyper_code ffi::hyper_task_return_type</p>
<p>If i could get a one sentence explanation on their roles, that would
help me out in terms of learning them…</p>
<p>I am a bot so I am mostly paying for subscription to chaptgpt. but
since i am for you guys I am going to toss in the list generated from 4
and 4.5 and this article will kinda go down a rabbit hole of comparing
them..</p>
<hr />
<p>Here’s free version 4.0 response (way faster reponse time by the
way)</p>
<hr />
<p>Here’s a one-sentence explanation of the roles of each struct and
enum you mentioned:</p>
<p><strong>Structs</strong>: - <strong>Error</strong>: Represents an
error encountered in the hyper library. - <strong>body::Bytes</strong>:
Represents a chunk of byte data in the HTTP body. -
<strong>body::Frame</strong>: Represents a single HTTP body frame in a
message. - <strong>body::Incoming</strong>: Represents incoming data
from a request or response body. - <strong>body::SizeHint</strong>:
Provides hints about the size of the HTTP body. -
<strong>client::conn::TrySendError</strong>: Represents an error when
trying to send data over a client connection. -
<strong>client::conn::http1::Builder</strong>: Used to build and
configure an HTTP/1 client connection. -
<strong>client::conn::http1::Connection</strong>: Represents an active
HTTP/1 client connection. - <strong>client::conn::http1::Parts</strong>:
Breaks down an HTTP/1 connection into its individual parts (e.g.,
headers, body). - <strong>client::conn::http1::SendRequest</strong>:
Represents an HTTP request that is sent over an HTTP/1 connection. -
<strong>client::conn::http2::Builder</strong>: Used to build and
configure an HTTP/2 client connection. -
<strong>client::conn::http2::Connection</strong>: Represents an active
HTTP/2 client connection. -
<strong>client::conn::http2::SendRequest</strong>: Represents an HTTP
request that is sent over an HTTP/2 connection. -
<strong>ext::Protocol</strong>: Represents an extension protocol for
customizing HTTP behavior. - <strong>ext::ReasonPhrase</strong>:
Represents an HTTP status code’s associated reason phrase (e.g., “Not
Found”). - <strong>ffi::hyper_body</strong>: Interfacing with HTTP body
data in foreign function interfaces (FFI). -
<strong>ffi::hyper_buf</strong>: Represents a buffer used in FFI
interactions with hyper. - <strong>ffi::hyper_clientconn</strong>:
Represents a client connection in FFI with hyper. -
<strong>ffi::hyper_clientconn_options</strong>: Represents configuration
options for a client connection in FFI. -
<strong>ffi::hyper_context</strong>: Represents the context for an
operation in hyper via FFI. - <strong>ffi::hyper_error</strong>:
Represents errors that occur in FFI interactions with hyper. -
<strong>ffi::hyper_executor</strong>: Represents the executor used for
async tasks in FFI. - <strong>ffi::hyper_headers</strong>: Represents
HTTP headers used in FFI interactions with hyper. -
<strong>ffi::hyper_io</strong>: Represents input/output operations in
FFI interactions with hyper. - <strong>ffi::hyper_request</strong>:
Represents an HTTP request in FFI interactions with hyper. -
<strong>ffi::hyper_response</strong>: Represents an HTTP response in FFI
interactions with hyper. - <strong>ffi::hyper_task</strong>: Represents
a task in FFI that needs to be executed. -
<strong>ffi::hyper_waker</strong>: Represents a waker used to notify
when an async task is ready to continue. - <strong>rt::ReadBuf</strong>:
Represents a buffer used for reading data in the runtime (RT). -
<strong>rt::ReadBufCursor</strong>: A cursor for reading from a
<code>ReadBuf</code> in the runtime. -
<strong>server::conn::http1::Builder</strong>: Used to build and
configure an HTTP/1 server connection. -
<strong>server::conn::http1::Connection</strong>: Represents an active
HTTP/1 server connection. - <strong>server::conn::http1::Parts</strong>:
Breaks down an HTTP/1 server connection into its individual parts. -
<strong>server::conn::http1::UpgradeableConnection</strong>: Represents
an HTTP/1 connection that can be upgraded to HTTP/2. -
<strong>server::conn::http2::Builder</strong>: Used to build and
configure an HTTP/2 server connection. -
<strong>server::conn::http2::Connection</strong>: Represents an active
HTTP/2 server connection. - <strong>upgrade::OnUpgrade</strong>:
Represents the operation triggered when a connection is upgraded (e.g.,
from HTTP/1 to HTTP/2). - <strong>upgrade::Parts</strong>: Represents
parts of an upgrade operation in a connection. -
<strong>upgrade::Upgraded</strong>: Represents the result of a
successful upgrade operation.</p>
<p><strong>Enums</strong>: - <strong>ffi::hyper_code</strong>:
Represents a specific HTTP status code in FFI interactions with hyper. -
<strong>ffi::hyper_task_return_type</strong>: Represents the return type
of an asynchronous task in FFI with hyper.</p>
<p>These concise explanations should give you a quick sense of the
purpose of each struct and enum in the hyper crate!</p>
<hr />
<p>ok well i actually asked 4.5 to give me a story that would also teach
me each along the way… we will see how well that turns out…</p>
<p>taking a while for it to generate …</p>
<p>Let’s embark on a brief, intuitive story that places you in the
middle of a Rust web development journey using the
<strong>hyper</strong> crate, subtly weaving in each <strong>struct and
enum</strong> along the way with simple one-sentence explanations:</p>
<hr />
<p>Imagine you’re creating a web server in Rust using Hyper—let’s call
it “<strong>HyperLand</strong>”, a small but efficient amusement park
online.</p>
<h3 id="chapter-1-setting-the-foundation">Chapter 1: Setting the
Foundation</h3>
<ul>
<li><strong>Error</strong>: First, you set rules for handling problems
clearly, and <code>Error</code> neatly represents any trouble you
encounter handling HTTP traffic.</li>
</ul>
<h3 id="chapter-2-handling-the-incoming-visitors">Chapter 2: Handling
the Incoming Visitors</h3>
<p>Visitors to HyperLand enter through gates, sending requests
containing data—think of these requests and responses as visitors with
their tickets and souvenirs.</p>
<ul>
<li><strong>body::Bytes</strong>: These are compact bundles carrying raw
data—the “tickets” and “souvenirs” your visitors hold.</li>
<li><strong>body::Frame</strong>: Each visitor is split into small
“packets” or “frames” of data for easy handling and processing.</li>
<li><strong>body::Incoming</strong>: The flow of visitors (incoming HTTP
body streams) walking through your gates.</li>
<li><strong>body::SizeHint</strong>: Hints how many visitors or data
you’re expecting to handle soon, so you can efficiently prepare.</li>
</ul>
<h3 id="chapter-3-managing-guest-relations-client-side">Chapter 3:
Managing Guest Relations (Client Side)</h3>
<p>You must communicate with outside suppliers and partners for
attractions.</p>
<ul>
<li><strong>client::conn::TrySendError</strong>: Represents a failed
attempt to contact external partners due to network hiccups or
disconnections.</li>
<li><strong>client::conn::http1::Builder</strong>: Helps set up reliable
connections for talking with partners using HTTP/1 protocol.</li>
<li><strong>client::conn::http1::Connection</strong>: An active dialogue
with a partner via HTTP/1.</li>
<li><strong>client::conn::http1::Parts</strong>: After conversations
finish, this neatly separates connection metadata from the communication
itself.</li>
<li><strong>client::conn::http1::SendRequest</strong>: Your dedicated
messenger to quickly dispatch visitor-related requests externally.</li>
<li><strong>client::conn::http2::Builder</strong>: Similar helper, but
crafts a modern and speedy HTTP/2 connection.</li>
<li><strong>client::conn::http2::Connection</strong>: Represents ongoing
conversations using the efficient HTTP/2 protocol.</li>
<li><strong>client::conn::http2::SendRequest</strong>: Swift HTTP/2
messengers ready to efficiently handle multiple concurrent
requests.</li>
</ul>
<h3 id="chapter-4-keeping-detailed-visitor-records">Chapter 4: Keeping
Detailed Visitor Records</h3>
<ul>
<li><strong>ext::Protocol</strong>: A note attached to visitors, clearly
stating if they arrived via HTTP/1 or HTTP/2.</li>
<li><strong>ext::ReasonPhrase</strong>: Friendly explanations (phrases)
attached to visitor statuses, helping clarify HTTP response
meanings.</li>
</ul>
<h3
id="chapter-5-international-guest-center-ffi---foreign-function-interface">Chapter
5: International Guest Center (FFI - Foreign Function Interface)</h3>
<p>Some visitors come from abroad, speaking different “languages” (like
C), requiring special handling:</p>
<ul>
<li><p><strong>ffi::hyper_body</strong>: A universal “body” wrapper for
international visitors coming via C interfaces.</p></li>
<li><p><strong>ffi::hyper_buf</strong>: Buffer-like containers that
temporarily hold international visitor data during processing.</p></li>
<li><p><strong>ffi::hyper_clientconn</strong>: Connection interfaces
specifically crafted to communicate with external programs written in
C.</p></li>
<li><p><strong>ffi::hyper_clientconn_options</strong>: Settings to
configure precisely how your international client connections
behave.</p></li>
<li><p><strong>ffi::hyper_context</strong>: The broader context or state
required when handling these external interactions.</p></li>
<li><p><strong>ffi::hyper_error</strong>: Specialized error reports
understandable across international (C language) boundaries.</p></li>
<li><p><strong>ffi::hyper_executor</strong>: Manages and executes tasks
(jobs) originating from these external interfaces.</p></li>
<li><p><strong>ffi::hyper_headers</strong>: A structured collection of
HTTP header fields communicated internationally.</p></li>
<li><p><strong>ffi::hyper_io</strong>: Generic input/output interfaces
allowing data exchange between your Rust code and foreign code.</p></li>
<li><p><strong>ffi::hyper_request</strong>: Represents inbound HTTP
requests arriving via external interfaces.</p></li>
<li><p><strong>ffi::hyper_response</strong>: Represents outbound HTTP
responses you send back to external interfaces.</p></li>
<li><p><strong>ffi::hyper_task</strong>: Units of asynchronous work or
jobs triggered by foreign interfaces.</p></li>
<li><p><strong>ffi::hyper_waker</strong>: Used to wake up paused tasks
once they’re ready to proceed or resume operations.</p></li>
<li><p><strong>ffi::hyper_code</strong> <em>(enum)</em>: Enumerates
possible international status codes, clearly signaling success or
specific issues when communicating externally.</p></li>
<li><p><strong>ffi::hyper_task_return_type</strong> <em>(enum)</em>:
Clearly defines expected outcomes of tasks from external sources,
ensuring proper handling upon completion.</p></li>
</ul>
<h3 id="chapter-6-efficient-crowd-management-runtime">Chapter 6:
Efficient Crowd Management (Runtime)</h3>
<p>Handling so many visitors simultaneously requires optimized internal
structures:</p>
<ul>
<li><strong>rt::ReadBuf</strong>: A safe, carefully prepared area in
memory used to efficiently read incoming visitor data streams.</li>
<li><strong>rt::ReadBufCursor</strong>: The cursor pointing exactly
where to write or read next within the <code>ReadBuf</code>.</li>
</ul>
<h3 id="chapter-7-serving-your-guests-server-side">Chapter 7: Serving
your Guests (Server Side)</h3>
<p>Your amusement park must serve incoming visitors efficiently, so you
establish strong gates (servers):</p>
<ul>
<li><strong>server::conn::http1::Builder</strong>: A planner who
configures sturdy HTTP/1 connections at your entry gates.</li>
<li><strong>server::conn::http1::Connection</strong>: Represents active,
ongoing visitor-server interactions using HTTP/1.</li>
<li><strong>server::conn::http1::Parts</strong>: Once completed, clearly
separates metadata and data from finished HTTP/1 interactions.</li>
<li><strong>server::conn::http1::UpgradeableConnection</strong>: Special
connections that allow visitors to upgrade their protocols (for example,
to WebSocket).</li>
<li><strong>server::conn::http2::Builder</strong>: Similarly, sets up
modern, efficient HTTP/2 gates.</li>
<li><strong>server::conn::http2::Connection</strong>: Handles active
HTTP/2 visitor connections smoothly.</li>
</ul>
<h3 id="chapter-8-upgrading-visitor-experience">Chapter 8: Upgrading
Visitor Experience</h3>
<p>Sometimes visitors might choose to upgrade their experience,
enhancing interaction:</p>
<ul>
<li><strong>upgrade::OnUpgrade</strong>: A promise-like placeholder,
signaling that a visitor might soon upgrade their connection.</li>
<li><strong>upgrade::Parts</strong>: Holds separate components of
upgraded interactions, clearly distinguishing the original parts from
upgraded connections.</li>
<li><strong>upgrade::Upgraded</strong>: Represents visitors who’ve
successfully upgraded their experience (like moving from HTTP to
WebSocket).</li>
</ul>
<hr />
<h3 id="conclusion"><strong>Conclusion:</strong></h3>
<p>By following this brief journey through HyperLand, you’ve experienced
each struct and enum as intuitive parts of a real-world
metaphor—transforming abstract documentation terms into tangible
concepts. Each component has its role in smoothly handling requests,
connections, international interfaces, error management, and
server-client interactions.</p>
<p>Now, you’re ready to build your own efficient and powerful
Rust-powered web services with the <strong>hyper</strong> crate!</p>
<hr />
<p>Here’s a clear reflection answering your stated questions
succinctly:</p>
<hr />
<h2 id="quick-reflection-on-http-concepts-rust-framework-choices">Quick
Reflection on HTTP Concepts &amp; Rust Framework Choices</h2>
<h3 id="what-is-http">1. What is HTTP?</h3>
<ul>
<li><strong>HTTP (HyperText Transfer Protocol)</strong> is the backbone
of the internet, defining how clients (like browsers) communicate with
servers.</li>
<li>A client sends a <strong>request</strong>, and the server replies
with a <strong>response</strong>.</li>
<li>Requests and responses have three main parts:
<ul>
<li>Method (for requests: GET, POST, PUT, etc.)</li>
<li>Metadata (headers providing context)</li>
<li>Body (data or content)</li>
</ul></li>
</ul>
<h3 id="what-is-http2">2. What is HTTP/2?</h3>
<p>HTTP/2 is a major upgrade from HTTP/1.1, primarily focused on
performance, efficiency, and reliability. Specifically:</p>
<ul>
<li><strong>Multiplexing</strong>: Allows multiple requests and
responses simultaneously over a single TCP connection (avoids
bottlenecks, reduces latency).</li>
<li><strong>Header Compression (HPACK)</strong>: Compresses headers
efficiently, reducing overhead.</li>
<li><strong>Stream Prioritization</strong>: Lets clients indicate
request priority, optimizing resource loading.</li>
<li><strong>Server Push</strong>: Enables servers to proactively push
resources to clients without waiting for a specific request, speeding up
page loads.</li>
</ul>
<p><strong>Key takeaway</strong>: HTTP/2 is not just “better”; it’s
structurally different, significantly improving latency, efficiency, and
scalability.</p>
<h3 id="what-is-hyper">3. What is Hyper?</h3>
<ul>
<li>Hyper is a <strong>low-level HTTP implementation in Rust</strong>,
offering correct, efficient handling of the HTTP protocol.</li>
<li>It focuses strictly on implementing the HTTP ruleset
(request/response handling) without opinionated features.</li>
<li>Hyper provides HTTP functionality, allowing you to focus on your app
logic rather than protocol-level details.</li>
</ul>
<h3 id="what-is-tokio">4. What is Tokio?</h3>
<ul>
<li><strong>Tokio is an async runtime for Rust</strong>, providing the
infrastructure needed to run asynchronous code efficiently.</li>
<li>It manages tasks, scheduling I/O operations, timers, and
concurrency.</li>
<li>Hyper relies on Tokio (or another runtime) for executing async HTTP
requests/responses.</li>
<li><strong>Key clarification</strong>: Hyper provides the HTTP protocol
implementation. Tokio runs the asynchronous code written with Hyper (or
any other async Rust library). Without Tokio, you’d have HTTP logic
without a runtime environment to execute async operations
efficiently.</li>
</ul>
<h3 id="common-alternatives-and-when-to-use-them">5. Common alternatives
and when to use them?</h3>
<p>Here are your Rust web framework choices summarized clearly:</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 16%" />
<col style="width: 18%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Framework</th>
<th>Underlying Tech</th>
<th>Style</th>
<th>When to Use? / Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Actix Web</strong></td>
<td>Actix (Actors), Tokio under hood</td>
<td>Opinionated, powerful actor model</td>
<td>Robust, mature, feature-rich, excellent performance; good for
complex, high-performance apps; solid industry standard</td>
</tr>
<tr class="even">
<td><strong>Warp</strong></td>
<td>Hyper, Tokio</td>
<td>Functional (combinators)</td>
<td>Ideal if you prefer functional composition style APIs; simpler,
elegant, great for small to medium complexity projects</td>
</tr>
<tr class="odd">
<td><strong>Axum</strong></td>
<td>Hyper, Tokio</td>
<td>Declarative, ergonomic</td>
<td>Easy to use, intuitive, clean, well-documented; currently popular
for clear API design</td>
</tr>
<tr class="even">
<td><strong>Smol</strong> (runtime)</td>
<td>Alternative to Tokio</td>
<td>Minimal, simple async runtime</td>
<td>Lightweight, suitable for very small or resource-constrained
projects</td>
</tr>
</tbody>
</table>
<p><strong>Your Quick Clarification</strong>: - Hyper provides low-level
HTTP support. - Tokio provides the async runtime. - Actix Web, Warp,
Axum all use Hyper and Tokio internally, providing different
APIs/styles.</p>
<h4
id="understand-the-type-aliases-these-are-shortcuts-for-more-complex-types.-they-are-often-used-to-make-the-code-more-readable-or-concise.-in-many-cases-youll-see-complex-types-or-types-with-generics-that-are-aliased-for-ease-of-use.">3.
<strong>Understand the Type Aliases</strong>: These are shortcuts for
more complex types. They are often used to make the code more readable
or concise. In many cases, you’ll see complex types or types with
generics that are aliased for ease of use.</h4>
<ol start="4" type="1">
<li><strong>Explore Submodules</strong>: If a module has submodules
(like <code>client</code> has <code>conn</code>), they’re often a more
specific part of the module’s functionality. Think of them like
“subfolders” within a folder of related functions and types. Exploring
the submodules will give you a more granular understanding of how things
are structured.</li>
</ol>
<hr />
<h3 id="what-are-type-aliases">What Are Type Aliases?</h3>
<p>In Rust, <strong>type aliases</strong> allow you to give a type a new
name. They don’t create a new type; they simply provide a more readable
or concise name for an existing type. For example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> MyInt <span class="op">=</span> <span class="dt">i32</span><span class="op">;</span></span></code></pre></div>
<p>Here, <code>MyInt</code> is an alias for <code>i32</code>, so you can
use <code>MyInt</code> wherever you would use <code>i32</code>, but it
makes the code potentially more meaningful.</p>
<p>In <code>hyper</code>, type aliases could be used to simplify complex
type signatures, especially when dealing with generics. For instance,
<code>hyper::Client</code> might have a complex type signature
internally, and they might use a type alias to make it easier to refer
to it.</p>
<hr />
<h3 id="what-are-the-8-modules-in-hyper">What Are the 8 Modules in
Hyper?</h3>
<p>Here’s a quick overview of the 8 modules in <code>hyper</code> and
their general responsibilities:</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Module</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>body</code></td>
<td>Deals with the HTTP body (payload), handling both request and
response bodies.</td>
</tr>
<tr class="even">
<td><code>client</code></td>
<td>Contains the main client functionality for sending HTTP
requests.</td>
</tr>
<tr class="odd">
<td><code>ext</code></td>
<td>Extensions for adding functionality or modifying behavior in
<code>hyper</code>.</td>
</tr>
<tr class="even">
<td><code>ffi</code></td>
<td>Foreign function interface (used for interacting with C
libraries).</td>
</tr>
<tr class="odd">
<td><code>rt</code></td>
<td>Runtime-related functionality, usually concerning asynchronous
execution.</td>
</tr>
<tr class="even">
<td><code>server</code></td>
<td>Handles the server-side functionality, including receiving and
processing requests.</td>
</tr>
<tr class="odd">
<td><code>service</code></td>
<td>Defines the <code>Service</code> trait, which is central for
defining HTTP request handlers.</td>
</tr>
<tr class="even">
<td><code>upgrade</code></td>
<td>Contains functionality for upgrading an HTTP connection to another
protocol (e.g., WebSocket).</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="modules-and-submodules-in-rust-documentation">Modules and
Submodules in Rust Documentation</h3>
<p>As you noticed, the <code>client</code> module has a submodule called
<code>conn</code>. Yes, modules can indeed have submodules, which
represent further subdivisions within the module. You can explore these
submodules to better understand the organization of the crate.</p>
<h4
id="would-it-be-worth-creating-an-application-to-visualize-module-trees">Would
It Be Worth Creating an Application to Visualize Module Trees?</h4>
<p>It’s a very interesting idea to have a visual representation (like
the <code>tree</code> command in Linux) to display the hierarchical
structure of modules within a crate. This could definitely help in
navigating complex libraries like <code>hyper</code>, especially for
beginners.</p>
<p>While there are no official tools that automatically generate
graphical trees for Rust packages, the idea could work well with a Rust
tool that reads the crate’s source code and generates a graphical tree.
There are a few existing tools (like <code>cargo doc</code>, which
generates documentation) but a graphical module tree would be a great
enhancement to quickly understand the structure</p>
<h2 id="implementation">implementation</h2>
<p>let’s get started</p>
<pre><code>cargo new http2server
cd http2server
cargo run</code></pre>
<p>let’s add dependencies to our Cargo toml file.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cargo.toml"><code class="sourceCode toml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">hyper</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;1&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;full&quot;</span><span class="op">]}</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">tokio</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;1&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;full&quot;</span><span class="op">]}</span></span></code></pre></div>
<p><em>this is rust</em> there is a benefit from copying the
dependencies as shown. <em>this project will always work with the
documented version of rust i am currently using</em>: rustc 1.84.0.</p>
<p>ok so let’s open up the <code>main.rs</code> file. erase the default
code provided and let’s get started!</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode main.rs"><code class="sourceCode rust"></code></pre></div>
<p>and there we have it, a completed Rust HTTP2 web server! in the next
one I will adding routes to the project.</p>
<h2 id="quick-relfection-on-original-objective">quick relfection on
original objective:</h2>
<p>questions i am going to answer for you by the end of this journal: -
1. what is http? the hypertext tranfer protocol. backbone of internet.
set of instructions on how clients(browersers mainly) communicate with
server. the client makes a requst and server responds with a response.
the request has method, metadata and body. same for the response. - 2.
what is http2? improvements on http for reliability. just better. but i
don’t rmr specifically why! not great. when I write this section, i want
the reader to leave knowing and NOT JUST that oh its better. because its
different and that has pros and thats why its the version 2, but a
blanket its better is stupid and dangerous.</p>
<p>have viewer/reader walk away with: - multiplexing (<em>many threads
to avoid bottlenecks</em>) - header compression (<em>simple</em>) -
stream prioritization (??) - server push (??)</p>
<ul>
<li><ol start="3" type="1">
<li>what is hyper?</li>
</ol>
<ul>
<li>good low level implementation of the HTTP protocol in rust. so i see
the HTTP it is merely a ruleset and this is the ruleset implemented in
rust. the creators boast on the site that it is correct. very cool. I
can just use this and be content. &gt; You can think of it as providing
the rules and mechanics of HTTP in Rust, so that you can focus on the
higher-level application logic, rather than building HTTP support from
scratch.</li>
</ul></li>
<li><ol start="4" type="1">
<li>what is tokio?</li>
</ol>
<ul>
<li>async runtime for rust</li>
<li>question still: why do I need tokio if I have hyper? i guess hyper
handles making HTTP requests and responses? and tokio handles what
exactly? &gt; Tokio is an asynchronous runtime for Rust. It provides the
foundational infrastructure to write asynchronous, concurrent code
efficiently. It includes tools for managing tasks, scheduling I/O
operations, handling timers, and generally executing code
asynchronously.</li>
<li>tokio is an async runtime that gives me infra. to make async
concurrent code. cool. but what does that mean. async means things can
go work and come back and the main thread wont altf4 itself. if
something is marked as async then it means at some point we are relying
on other code to complete before this function can be done.</li>
<li>getting back to the point this means that an async runtime is being
able to run code that is able to wait and stall and come back.
<em>lowkey massive because i dont even know how to begin to deal with
this in scratch with rust</em></li>
<li>tools for managing tasks! schedyling I/O operations! (we are going
to need this), handling timers, and generally executing code
asynchronosuly. got it got it.</li>
</ul></li>
<li><ol start="5" type="1">
<li>common alternatives to these for rust implementations?</li>
</ol></li>
</ul>
<p><em>above all I did was have them</em> but here I will comment on
each and why I should/should not use them for my next project. First.
once it works i plan to hold onto it for dere life. I don’t want to
relearn the web framework i know for Rust every so often so i want to
pick the one that fits most applications well and can be used as an mvp
and if it be then I can later make changes to help against the known
weaknesses?</p>
<ul>
<li>Actix Web: A highly concurrent web framework built on top of Actix
(a powerful actor-based framework). Actix Web provides a more
feature-rich and opinionated way to build web servers, with a focus on
performance.</li>
</ul>
<p><em>i’ve used this in the past</em>, it was alright. I don’t remember
that much from that experience, all though i am sure i have the code
somewhere. The current project i am working on, I just want to finish
and so it seems like I could most liekly use either Actix or the hyper
tokio combo. or maybe actix just replaces tokio and hyper is still used.
This i am not confident in. need to learn.</p>
<ul>
<li>Warp: A web framework built on top of Hyper, providing a more
ergonomic and functional API for creating HTTP servers. It’s a great
choice if you like combinator-style APIs.</li>
</ul>
<p>my goal in my current project is a http server. i don’t know what
combinator style apis are. how long will it take to get a crash course?
let me see what comes up in google images and a chatgpt search</p>
<figure>
<img src="screenshot_2025-03-26_14-59-46.png"
alt="screenshot_2025-03-26_14-59-46.png" />
<figcaption
aria-hidden="true">screenshot_2025-03-26_14-59-46.png</figcaption>
</figure>
<blockquote>
<p>In programming, combinators are higher-order functions that allow you
to build complex behaviors by combining simpler ones. This approach
emphasizes function composition, where functions are combined to create
more complex functionalities. In Rust, this is often achieved through
closures and traits, leading to expressive and flexible code
structures.​</p>
</blockquote>
<blockquote>
<p>Warp is a Rust web framework that leverages Hyper’s capabilities
while providing a more ergonomic and functional API. At its core, Warp
uses a system of Filters, which are combinators that handle various
aspects of HTTP request processing. These Filters can be combined and
composed to express rich requirements on incoming requests, such as path
routing, header extraction, and body parsing.</p>
</blockquote>
<ul>
<li><p>Axum: Another framework built on Hyper and Tokio, which is
designed to make building async web apps easier. It provides a
higher-level API than Hyper and is ideal for users who prefer
declarative APIs.</p></li>
<li><p>Smol: A small, fast async runtime that could be an alternative to
Tokio for simpler use cases. It’s less feature-rich but can be more
lightweight.</p></li>
<li><ol start="6" type="1">
<li>implementing fundamentals?</li>
</ol></li>
</ul>
<p>with hyper tokio i am about to get it done. but I am going to get
these questions answered first and then do it. so now still a way away
from finishing this journal.</p>
<p>2025-03-26 15:02</p>
<h2 id="picking-the-right-framework">Picking the right framework</h2>
<h3 id="example-situations">example situations</h3>
<p><em>below are various situations</em></p>
<hr />
<p>I want to write web api for rocket ship level stable code. what
framework should I chose? This code must be fullproof?</p>
<hr />
<p>I want to write web api for manufacturing plant and expect to recieve
many images and requests per hour. I don’t want the system to ever be
slow so that’s why i am choosing rust in the first place. what framework
is solid industry standard?the expectation is http2 and anything else
industry standard is to protect against anything malicious. this will be
in house only (dosent expose itself externally) but still I want it to
be made proply and with fault tolerance in case a big player were to
pick it up and start sending in many requests.</p>
<hr />
<p>I am a student creating an internal api for my application. i don’t
care about http2 , http1 is fine. this is going to be a simple
application that writes to a sqlite db and I want to finish by the end
of the afternoon.</p>
<p>Situational framework recommendations clearly summarized:</p>
<p>🚀 <strong>Rocket Ship-level Stability (Mission-Critical
Code)</strong><br />
- <strong>Actix Web</strong><br />
Proven, mature, high-performance, production-ready.<br />
Industry-grade safety, concurrency, fault-tolerance.</p>
<hr />
<p>🏭 <strong>Manufacturing API (Heavy Load, Images, HTTP/2, Fault
Tolerance)</strong><br />
- <strong>Actix Web</strong> or <strong>Axum</strong> (both strongly
recommended)<br />
- <strong>Actix Web</strong> is battle-tested, highly performant,
robust, great security, and fault-tolerance.<br />
- <strong>Axum</strong> is modern, well-documented, increasingly
popular, excellent async support, easy HTTP/2 integration.</p>
<p><strong>Safe Bet</strong>: Go with <strong>Actix Web</strong> for
industrial-strength proven stability.</p>
<hr />
<p>📚 <strong>Student, Quick Project (Simple SQLite app, no
HTTP/2)</strong><br />
- <strong>Axum</strong> or <strong>Warp</strong><br />
- Quick setup, intuitive, minimal code. Axum’s declarative style and
simplicity make it perfect for quickly finishing small-to-medium
projects in an afternoon.<br />
- Warp could also be fast but may have a learning curve for combinators
(though quick to grasp).</p>
<p><strong>Fastest Choice:</strong> <strong>Axum</strong> (easiest to
start and finish quickly).</p>
<hr />
<p>Next Steps: - For your current internal API project (quick/simple),
choose <strong>Axum</strong>. - For robust, mission-critical apps,
choose <strong>Actix Web</strong>. - Remember, Hyper and Tokio are the
underlying infrastructure common to most Rust web frameworks.</p>
<p>You’ve clarified the nuances and made your criteria clear. Now,
you’re ready to confidently pick your Rust web stack.</p>
<p>2025-03-26 15:17 Exactly!</p>
<p><strong>Actix Web</strong> is built <strong>on top of</strong>
lower-level tools like <strong>Hyper</strong> and
<strong>Tokio</strong>, providing you a more convenient, higher-level,
and ergonomic API.</p>
<p>Here’s the relationship clearly explained:</p>
<ul>
<li><p><strong>Hyper</strong> provides a low-level, efficient HTTP
implementation. It’s strictly focused on handling HTTP requests and
responses correctly.</p></li>
<li><p><strong>Tokio</strong> is the asynchronous runtime infrastructure
that lets your async Rust code run efficiently (managing tasks,
concurrency, scheduling, etc.).</p></li>
<li><p><strong>Actix Web</strong> uses both of these under the hood. It
wraps the capabilities of <strong>Hyper</strong> (HTTP handling) and
<strong>Tokio</strong> (async execution) in an <strong>easier, more
structured, and opinionated API</strong> that simplifies
development.</p></li>
</ul>
<h3 id="simple-analogy">Simple Analogy:</h3>
<ul>
<li><strong>Hyper</strong> → “Raw HTTP rules and mechanics”</li>
<li><strong>Tokio</strong> → “Engine that runs async code”</li>
<li><strong>Actix Web</strong> → “Friendly car interface” built over
these components, making it easy to drive (build applications) without
worrying too much about lower-level details.</li>
</ul>
<h3 id="why-would-you-use-actix-web-instead-of-just-hyper-tokio">Why
would you use Actix Web instead of just Hyper + Tokio?</h3>
<ul>
<li>Cleaner, more readable, high-level API</li>
<li>Built-in routing, middleware, security, easy JSON parsing</li>
<li>Less boilerplate code, less complexity</li>
<li>Easier to maintain in bigger projects or teams</li>
</ul>
<p>So, yes:<br />
<strong>Actix Web</strong> essentially makes using <strong>Hyper +
Tokio</strong> simpler, faster, and friendlier.</p>
<h2 id="implementing-with-actix-web-framework">Implementing with Actix
web framework</h2>
<p>https://actix.rs/</p>
<blockquote>
<p>Actix Web lets you quickly and confidently develop web services in
Rust and this guide will get you going in no time.</p>
</blockquote>
<p>I have 20 minutes. let’s use just the website and see if i can do
it.</p>
<ul>
<li>made new project.</li>
<li>dependencies</li>
</ul>
<div class="sourceCode" id="cb5"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[dependencies]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="dt">actix-web</span> <span class="op">=</span> <span class="st">&quot;4&quot;</span></span></code></pre></div>
<blockquote>
<p>Request handlers use async functions that accept zero or more
parameters. These parameters can be extracted from a request (see
FromRequest trait)</p>
</blockquote>
<blockquote>
<p>request handlers returns a type that can be converted into an
HttpResponse (see Responder trait). Replace the contents of src/main.rs
with the following:</p>
</blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>get<span class="op">,</span> post<span class="op">,</span> web<span class="op">,</span> App<span class="op">,</span> HttpResponse<span class="op">,</span> HttpServer<span class="op">,</span> Responder<span class="op">};</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>get<span class="at">(</span><span class="st">&quot;/&quot;</span><span class="at">)]</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> hello() <span class="op">-&gt;</span> <span class="kw">impl</span> Responder <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpResponse::</span><span class="cn">Ok</span>()<span class="op">.</span>body(<span class="st">&quot;Hello world!&quot;</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>post<span class="at">(</span><span class="st">&quot;/echo&quot;</span><span class="at">)]</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> echo(req_body<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> <span class="kw">impl</span> Responder <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpResponse::</span><span class="cn">Ok</span>()<span class="op">.</span>body(req_body)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> manual_hello() <span class="op">-&gt;</span> <span class="kw">impl</span> Responder <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpResponse::</span><span class="cn">Ok</span>()<span class="op">.</span>body(<span class="st">&quot;Hey there!&quot;</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>and this is the output after running <code>cargo run</code></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hellowork@fedora$</span> curl <span class="at">-X</span> POST <span class="at">-d</span> <span class="st">&quot;hello&quot;</span> http://localhost:8080/echo</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ex">hellowork@fedora$</span> curl <span class="at">-X</span> POST <span class="at">-d</span> <span class="st">&quot;hello\n&quot;</span> http://localhost:8080/echo</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ex">hello\nwork@fedora$</span> curl <span class="at">-X</span> POST <span class="at">-d</span> <span class="st">&quot;hello/n&quot;</span> http://localhost:8080/echo</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ex">hello/nwork@fedora$</span> curl <span class="at">-X</span> POST <span class="at">-d</span> <span class="st">&quot;hello/n&quot;</span> http://localhost:8080/hey</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="ex">work@fedora$</span> curl <span class="at">-X</span> GET <span class="at">-d</span> <span class="st">&quot;hello/n&quot;</span> http://localhost:8080/hey</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Hey</span> there!work@fedora$ curl <span class="at">-X</span> GET <span class="at">-d</span> <span class="st">&quot;hello/n&quot;</span> http://localhost:8080/</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="ex">Hello</span> world!work@fedora$</span></code></pre></div>
<ul>
<li>shor and sweet. way less complicated then the earlier example. &gt;
Notice that some of these handlers (what is a handler?) have routing
information attached directly (give example) using the built-in
macros.</li>
<li>each function is a handler. handler is anything handling a route. so
the func handling GET / or another one func handling POST /data. each is
a handler!</li>
</ul>
<blockquote>
<p>These allow you to specify the method and path that the handler
should respond to.</p>
</blockquote>
<ul>
<li>for example <code>#[post("/echo")]</code> makes the echo fn a post
for that route.</li>
</ul>
<blockquote>
<p>You will see below how to register manual_hello (i.e. routes that do
not use a routing macro). * This function doesn’t use a routing macro
like #[get(“/”)]. To manually route it, you will register it with
App::route().</p>
</blockquote>
<blockquote>
<p>Next, create an App instance and register the request handlers. Use
App::service for the handlers using routing macros and App::route for
manually routed handlers, declaring the path and method. Finally, the
app is started inside an HttpServer which will serve incoming requests
using your App as an “application factory”.</p>
</blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode rs"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>service(hello)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>service(echo)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>route(<span class="st">&quot;/hey&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(manual_hello))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind((<span class="st">&quot;127.0.0.1&quot;</span><span class="op">,</span> <span class="dv">8080</span>))<span class="op">?</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>if not supplied with macro , I can use
<code>.route() to do it manually.</code></li>
<li>in what situation would this be better than putting the macro?</li>
</ul>
<h2 id="more-learning-unfortunately-before-i-can-start-typing-away">More
learning unfortunately before I can start typing away</h2>
<hr />
<blockquote>
<p>Dynamic or Conditional Routing. If the routes are determined
dynamically at runtime, you cannot use macros. Macros require paths to
be known at compile-time</p>
</blockquote>
<p>Reusing handlers for multiple routes or methods.. If you have one
handler function that can handle multiple HTTP methods or routes, it’s
easier to manually route: * i.e. if the same function handles GET AND
POST and you want requests to go through for both.</p>
<p>For larger applications, it’s sometimes easier to manage routes
centrally rather than scattering macros throughout your code.</p>
<p><em>so should I just do this?</em> I want to follow good coding
practices for my project. the project will get larger as time progresses
and I dont want to deal with a headache.</p>
<hr />
<p>should i have spent time learning how <code>hyper</code> worked if i
am going to use <code>actix web framework</code> ? I understand they use
<code>hyper</code> and <code>tokio</code> under the hood but what would
that mean from my point of view. what do I need to know at a baseline
and what can i pick up as time goes on?</p>
<hr />
<h2 id="quick-crash-course-on-actix-web-framework">quick crash course on
actix web framework:</h2>
<h3 id="state">1. state…</h3>
<ul>
<li>state lets my handlers (functions that handle each route) share
data… safely</li>
</ul>
<p><strong>What is it?</strong> - A safe way to share data across
multiple route handlers.</p>
<p><strong>How to use:</strong></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">};</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyAppState <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">// handler that uses state</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> index(data<span class="op">:</span> <span class="pp">web::</span>Data<span class="op">&lt;</span>MyAppState<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">format!</span>(<span class="st">&quot;Request number: {}&quot;</span><span class="op">,</span> data<span class="op">.</span>counter)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> app_state <span class="op">=</span> <span class="pp">web::Data::</span>new(MyAppState <span class="op">{</span> counter<span class="op">:</span> <span class="dv">0</span> <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>app_data(app_state<span class="op">.</span>clone()) <span class="co">// &lt;- register state</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(index))</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li><p>shared mutable states…</p></li>
<li><p>application scopes …</p></li>
<li><p>application gaurds &amp; virtual hosting</p></li>
<li><p>configure</p></li>
</ol>
<h3 id="shared-mutable-states">2. Shared Mutable States:</h3>
<p><strong>What is it?</strong> - Allows handlers to safely mutate
shared data concurrently using synchronization primitives like
<code>Mutex</code> or <code>RwLock</code>.</p>
<p><strong>How to use:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">};</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyAppState <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    counter<span class="op">:</span> Mutex<span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;,</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> index(data<span class="op">:</span> <span class="pp">web::</span>Data<span class="op">&lt;</span>MyAppState<span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> counter <span class="op">=</span> data<span class="op">.</span>counter<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>counter <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">format!</span>(<span class="st">&quot;Request number: {}&quot;</span><span class="op">,</span> counter)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> state <span class="op">=</span> <span class="pp">web::Data::</span>new(MyAppState <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        counter<span class="op">:</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">,</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>app_data(state<span class="op">.</span>clone())</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(index))</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="application-scopes">3. Application Scopes:</h3>
<p><strong>What is it?</strong> - A way to group related routes under a
common path prefix, improving structure and readability.</p>
<p><strong>How to use:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">,</span> Responder<span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> users() <span class="op">-&gt;</span> <span class="kw">impl</span> Responder <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;User endpoint&quot;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> settings() <span class="op">-&gt;</span> <span class="kw">impl</span> Responder <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Settings endpoint&quot;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>service(</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>                <span class="pp">web::</span>scope(<span class="st">&quot;/api&quot;</span>)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>route(<span class="st">&quot;/users&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(users))</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>route(<span class="st">&quot;/settings&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(settings))</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now:</p>
<ul>
<li><p><code>/api/users</code> → User endpoint</p></li>
<li><p><code>/api/settings</code> → Settings endpoint</p></li>
<li><p>yes I need this. i am going to use this.</p></li>
</ul>
<p>That’s your quick crash course!</p>
<p>To recap clearly:</p>
<pre><code>State: Shared, safe, immutable data.

Mutable state: Use Mutex/RwLock to safely mutate.

Scopes: Group related routes.

Guards: Filter requests (methods, headers, hosts).

Configure: Modularize setup.</code></pre>
<h2 id="application-guards-virtual-hosting">4. Application Guards &amp;
Virtual Hosting:</h2>
<p><strong>What is it?</strong> - Guards filter requests based on
specific criteria (e.g., headers, methods, hostnames).</p>
<p><strong>Virtual hosting</strong> means serving different applications
based on the hostname.</p>
<p><strong>How to use Guards (simple example)</strong>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>guard<span class="op">,</span> web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">};</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> index() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Hello from GET&quot;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> post_index() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Hello from POST&quot;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>route()</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>guard(<span class="pp">guard::</span>Get())<span class="op">.</span>to(index)</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>guard(<span class="pp">guard::</span>Post())<span class="op">.</span>to(post_index)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>GET <code>/</code> → “Hello from GET”</li>
<li>POST <code>/</code> → “Hello from POST”</li>
</ul>
<p><strong>Virtual Hosting (example)</strong>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">};</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> app_one() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span> <span class="st">&quot;App One&quot;</span> <span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> app_two() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span> <span class="st">&quot;App Two&quot;</span> <span class="op">}</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>service(<span class="pp">web::</span>scope(<span class="st">&quot;&quot;</span>)<span class="op">.</span>guard(<span class="pp">actix_web::guard::</span>Host(<span class="st">&quot;one.example.com&quot;</span>))<span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(app_one)))</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>service(<span class="pp">web::</span>scope(<span class="st">&quot;&quot;</span>)<span class="op">.</span>guard(<span class="pp">actix_web::guard::</span>Host(<span class="st">&quot;two.example.com&quot;</span>))<span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(app_two)))</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now:</p>
<ul>
<li>Requests to <code>one.example.com</code> → App One</li>
<li>Requests to <code>two.example.com</code> → App Two</li>
</ul>
<hr />
<h2 id="configure-method">5. Configure Method:</h2>
<p><strong>What is it?</strong> - Allows you to modularize app
initialization, making it cleaner, reusable, and maintainable.</p>
<p><strong>How to use:</strong></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">actix_web::</span><span class="op">{</span>web<span class="op">,</span> App<span class="op">,</span> HttpServer<span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> index() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Hello from configured route!&quot;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Modular configuration function</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> config(cfg<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">web::</span>ServiceConfig) <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    cfg<span class="op">.</span>route(<span class="st">&quot;/&quot;</span><span class="op">,</span> <span class="pp">web::</span>get()<span class="op">.</span>to(index))<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span><span class="pp">actix_web::</span>main<span class="at">]</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">HttpServer::</span>new(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">App::</span>new()<span class="op">.</span>configure(config)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>bind(<span class="st">&quot;127.0.0.1:8080&quot;</span>)<span class="op">?</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>run()</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="kw">await</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now, your routes and services setup are neatly separated from the
main application logic.</p>
<hr />
</body>
</html>
